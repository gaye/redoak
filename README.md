# Overview

Thanks for checking out redoak! The aim of this project is to allow rapid
prototyping of HTML without getting in the way of your usual toolchain.  There
are no manifestos or revolutions, just faster development.

This tool currently provides:
- A server that serves up HTML that refreshes itself when it or any of its
  dependencies change.
- A method of creating widgets, which are basically HTML snippets and coupling
  it with some script logic  The widgets can be rendered server side or client
  side.
- A mixin system that allows widgets to take on multiple features.
- A straightforward way to split up components and test them with mock data.

Anti-goals:
- This project will never be a comprehensive toolkit. You are encouraged to use
  jQuery, backbone, underscore.js, whatever with redoak! It should be possible
  to use this with non-node projects: django, tornado, rails, and so forth.
- No database model middleware.
- Live updating of client code on your production server. The websocket
  connection is for development purposes only.

This project is brand new and is still evolving rapidly. Please give it a try
and file lots of bugs! Patches are appreciated as well.

# Diving in

The best way to get the gist of it is to try it. After you install redoak, just
run:

    bin/redoak public/todo.html

Navigate to http://localhost:3000/, fire up your favorite editor and start
playing. :) You can add files to public/, and they should be visible to the
webserver.

## BaseWidget

As you'll see in `todo.html`, BaseWidgets are responsible for managing the
html inside template tags once it is injected into the DOM. HTML injected
server side has auto-generated javascript constructs these widgets. HTML
created on the client side can be done like so:

    var widget = new BaseWidget(['mytemplatename']);
    widget.render(document.body, null, { data: 'data for template' });

BaseWidgets are hierarchical and may contain other BaseWidgets, so that you can
easily create and dispose groups of widgets with a single call.

### Methods of BaseWidget

See `lib/public/basewidget.js` for now.

### Lifecycle of BaseWidget

- Construction. At this point, it has no children and has no HTML it is
  responsible for.
- Rendering. After this, the widget is expected to be responsible for a DOM
  subtree. It should be able to modify it, to destroy it, and to add to it.
  It's probably a bad idea to have other objects change this subtree without
  the widget knowing about it (unless, the other object is a child widget).
- Disposal. The widget removes the subtree and cleans up after itself. After
  disposal, widget should not be reused.

## Events

Events in redoak serve two purposes. They serve the typical purpose of learning
something about a widget when its state changes, but events are also a way of
implementing methods on widgets. redoak's server code uses events to implement
template rendering and listening for events.

### The standard events of a widget

- `init(mixins)`: BaseWidget has just been constructed.
- `addChild(childWidget)`: child has been added. May happen before or happen
  widget has been rendered.
- `html()`: Called when `render()` is called to get the HTML for this type of
  widget. Normally implemented by autogenerated JS from redoak. Whoever
  implements `html()` should also implement `el()`.
- `els()`: Called right after widget has HTML attached, and before `rendered`.
  This gives the dictionary object used for `widget.el()`, and is normally
  implemented by autogenerated JS.
- `rendered(obj)`: widget just rendered with this object as the template
  parameters. Widget was either rendered using `assign()` where the HTML
  already existed or `render()` where HTML was generated.
- `fill(obj)`: Call this to change the HTML to reflect a new object.
  Normally implemented by autogenerated JS.
- `dispose()`: widget is being destroyed. All of its children have already been
  destroyed by this event.

# Understanding the code

### Server side code

Check out `lib/dependencies.js`. It's responsible for parsing the HTML, picking
out any CSS links or script tags, and watching them all for any changes. The
other important file is `lib/render.js`. It processes the tree, and generates
widget code and the final HTML.

### Client side code

All in `lib/public/`. The important file is really `basewidget.js`, which
contains the BaseWidget prototype.

`lib/public/util.js` contains the code for events.

# Testing

There's one test. :) Try it:

    node lib/reftest/reftest.js

It diffs the output of a sample oak file with the expected HTML. If nothing is
outputted, congratulations, it passed!

# Using it in your web app

Unless you want to contribute, I wouldn't recommend using it in anything
serious. Little thought has been given to browser compatibility or how to
incorporate it into a larger scope project. Optimization should be pretty
straightforward, but that work hasn't been done yet.

If that didn't scare you, here's how I'm doing it so far: I just require redoak
and use the express middleware with some static handlers for dependencies. For
session-specific data or DB model data, I've been including a separate JS file
so that everything else can stay static and cached. If you write a tag whose
src starts with a `/` like:

    <script src='/session.js'></script>

Then redoak will ignore it. There should probably be a way to render widgets
from your DB on the server, eventually.

# Contributors to redoak

- Emma Zhou: typo in README.
- Itai Zuckerman: todo example delete functionality. Bugfix for preserve mixin
  and disposing widgets. Bugfix for event listeners.
